{"ast":null,"code":"import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _inherits from\"@babel/runtime/helpers/inherits\";import*as React from'react';import TextInput from\"react-native-web/dist/exports/TextInput\";import Keyboard from\"react-native-web/dist/exports/Keyboard\";var KeyboardManager=function(_React$Component){_inherits(KeyboardManager,_React$Component);function KeyboardManager(){var _getPrototypeOf2;var _this;_classCallCheck(this,KeyboardManager);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_possibleConstructorReturn(this,(_getPrototypeOf2=_getPrototypeOf(KeyboardManager)).call.apply(_getPrototypeOf2,[this].concat(args)));_this.previouslyFocusedTextInput=null;_this.startTimestamp=0;_this.clearKeyboardTimeout=function(){if(_this.keyboardTimeout!==undefined){clearTimeout(_this.keyboardTimeout);_this.keyboardTimeout=undefined;}};_this.handlePageChangeStart=function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();var input=TextInput.State.currentlyFocusedField();TextInput.State.blurTextInput(input);_this.previouslyFocusedTextInput=input;_this.startTimestamp=Date.now();};_this.handlePageChangeConfirm=function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();Keyboard.dismiss();_this.previouslyFocusedTextInput=null;};_this.handlePageChangeCancel=function(){if(!_this.props.enabled){return;}_this.clearKeyboardTimeout();var input=_this.previouslyFocusedTextInput;if(input){if(Date.now()-_this.startTimestamp<100){_this.keyboardTimeout=setTimeout(function(){TextInput.State.focusTextInput(input);_this.previouslyFocusedTextInput=null;},100);}else{TextInput.State.focusTextInput(input);_this.previouslyFocusedTextInput=null;}}};return _this;}_createClass(KeyboardManager,[{key:\"componentWillUnmount\",value:function componentWillUnmount(){this.clearKeyboardTimeout();}},{key:\"render\",value:function render(){return this.props.children({onPageChangeStart:this.handlePageChangeStart,onPageChangeConfirm:this.handlePageChangeConfirm,onPageChangeCancel:this.handlePageChangeCancel});}}]);return KeyboardManager;}(React.Component);export{KeyboardManager as default};","map":{"version":3,"sources":["KeyboardManager.tsx"],"names":["KeyboardManager","React","Component","previouslyFocusedTextInput","startTimestamp","clearKeyboardTimeout","clearTimeout","handlePageChangeStart","input","TextInput","Date","handlePageChangeConfirm","Keyboard","handlePageChangeCancel","setTimeout","onPageChangeStart","onPageChangeConfirm","onPageChangeCancel"],"mappings":"mVAAA,MAAO,GAAP,CAAA,KAAA,KAAA,OAAA,C,4HAYqBA,GAAAA,CAAAA,e,kaAOXG,0B,CAA4C,I,OAC5CC,c,CAAyB,C,OAGzBC,oB,CAAuB,UAAM,CACnC,GAAI,KAAA,CAAA,eAAA,GAAJ,SAAA,CAAwC,CACtCC,YAAY,CAAC,KAAA,CAAbA,eAAY,CAAZA,CACA,KAAA,CAAA,eAAA,CAAA,SAAA,CAEH,C,QAEOC,qB,CAAwB,UAAM,CACpC,GAAI,CAAC,KAAA,CAAA,KAAA,CAAL,OAAA,CAAyB,CACvB,OAGF,CAAA,KAAA,CAAA,oBAAA,GAEA,GAAMC,CAAAA,KAAK,CAAGC,SAAS,CAATA,KAAAA,CAAd,qBAAcA,EAAd,CAGAA,SAAS,CAATA,KAAAA,CAAAA,aAAAA,CAAAA,KAAAA,EAGA,KAAA,CAAA,0BAAA,CAAA,KAAA,CAGA,KAAA,CAAA,cAAA,CAAsBC,IAAI,CAA1B,GAAsBA,EAAtB,C,QAGMC,uB,CAA0B,UAAM,CACtC,GAAI,CAAC,KAAA,CAAA,KAAA,CAAL,OAAA,CAAyB,CACvB,OAGF,CAAA,KAAA,CAAA,oBAAA,GAEAC,QAAQ,CAARA,OAAAA,GAGA,KAAA,CAAA,0BAAA,CAAA,IAAA,C,QAGMC,sB,CAAyB,UAAM,CACrC,GAAI,CAAC,KAAA,CAAA,KAAA,CAAL,OAAA,CAAyB,CACvB,OAGF,CAAA,KAAA,CAAA,oBAAA,GAGA,GAAML,CAAAA,KAAK,CAAG,KAAA,CAAd,0BAAA,CAEA,GAAA,KAAA,CAAW,CAQT,GAAIE,IAAI,CAAJA,GAAAA,GAAa,KAAA,CAAbA,cAAAA,CAAJ,GAAA,CAA4C,CAC1C,KAAA,CAAA,eAAA,CAAuBI,UAAU,CAAC,UAAM,CACtCL,SAAS,CAATA,KAAAA,CAAAA,cAAAA,CAAAA,KAAAA,EACA,KAAA,CAAA,0BAAA,CAAA,IAAA,CAF+B,CAAA,CAAjC,GAAiC,CAAjC,CADF,CAAA,IAKO,CACLA,SAAS,CAATA,KAAAA,CAAAA,cAAAA,CAAAA,KAAAA,EACA,KAAA,CAAA,0BAAA,CAAA,IAAA,CAEH,CACF,C,+GA7EsB,CACrB,KAAA,oBAAA,G,wCA8EO,CACP,MAAO,MAAA,KAAA,CAAA,QAAA,CAAoB,CACzBM,iBAAiB,CAAE,KADM,qBAAA,CAEzBC,mBAAmB,CAAE,KAFI,uBAAA,CAGzBC,kBAAkB,CAAE,KAHtB,sBAA2B,CAApB,CAAP,C,8BAjFyChB,KAAK,CAACC,S,CAA9BF,C,OAAAA,e","sourcesContent":["import * as React from 'react';\nimport { TextInput, Keyboard } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: () => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: number | null = null;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    const input = TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    Keyboard.dismiss();\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = null;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = null;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = null;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}