{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{getAssetForSource,loadSingleFontAsync,fontFamilyNeedsScoping,getNativeFontName}from\"./FontLoader\";var loaded={};var loadPromises={};export function processFontFamily(name){if(!name||!fontFamilyNeedsScoping(name)){return name;}if(!isLoaded(name)){if(__DEV__){if(isLoading(name)){console.error(\"You started loading the font \\\"\"+name+\"\\\", but used it before it finished loading.\\n\\n- You need to wait for Font.loadAsync to complete before using the font.\\n\\n- We recommend loading all fonts before rendering the app, and rendering only Expo.AppLoading while waiting for loading to complete.\");}else{console.error(\"fontFamily \\\"\"+name+\"\\\" is not a system font and has not been loaded through Font.loadAsync.\\n\\n- If you intended to use a system font, make sure you typed the name correctly and that it is supported by your device operating system.\\n\\n- If this is a custom font, be sure to load it with Font.loadAsync.\");}}return'System';}return\"ExpoFont-\"+getNativeFontName(name);}export function isLoaded(name){return loaded.hasOwnProperty(name);}export function isLoading(name){return loadPromises.hasOwnProperty(name);}export function loadAsync(nameOrMap,source){var fontMap,names,name,asset;return _regeneratorRuntime.async(function loadAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:if(!(typeof nameOrMap==='object')){_context2.next=6;break;}fontMap=nameOrMap;names=Object.keys(fontMap);_context2.next=5;return _regeneratorRuntime.awrap(Promise.all(names.map(function(name){return loadAsync(name,fontMap[name]);})));case 5:return _context2.abrupt(\"return\");case 6:name=nameOrMap;if(!loaded[name]){_context2.next=9;break;}return _context2.abrupt(\"return\");case 9:if(!loadPromises[name]){_context2.next=11;break;}return _context2.abrupt(\"return\",loadPromises[name]);case 11:if(source){_context2.next=13;break;}throw new Error(\"No source from which to load font \\\"\"+name+\"\\\"\");case 13:asset=getAssetForSource(source);loadPromises[name]=function _callee(){return _regeneratorRuntime.async(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return _regeneratorRuntime.awrap(loadSingleFontAsync(name,asset));case 3:loaded[name]=true;case 4:_context.prev=4;delete loadPromises[name];return _context.finish(4);case 7:case\"end\":return _context.stop();}}},null,null,[[0,,4,7]]);}();_context2.next=17;return _regeneratorRuntime.awrap(loadPromises[name]);case 17:case\"end\":return _context2.stop();}}});}if(module&&module.exports){var wasImportWarningShown=false;Object.defineProperty(exports,'Font',{get:function get(){if(!wasImportWarningShown){console.warn(\"The syntax \\\"import { Font } from 'expo-font'\\\" is deprecated. Use \\\"import * as Font from 'expo-font'\\\" or import named exports instead. Support for the old syntax will be removed in SDK 33.\");wasImportWarningShown=true;}return{processFontFamily:processFontFamily,isLoaded:isLoaded,isLoading:isLoading,loadAsync:loadAsync};}});}","map":{"version":3,"sources":["../src/Font.ts"],"names":[],"mappings":"4DAAA,OACE,iBADF,CAEE,mBAFF,CAGE,sBAHF,CAIE,iBAJF,oBASA,GAAM,CAAA,MAAM,CAAgC,EAA5C,CACA,GAAM,CAAA,YAAY,CAAsC,EAAxD,CASA,MAAM,SAAU,CAAA,iBAAV,CAA4B,IAA5B,CAA+C,CACnD,GAAI,CAAC,IAAD,EAAS,CAAC,sBAAsB,CAAC,IAAD,CAApC,CAA4C,CAC1C,MAAO,CAAA,IAAP,CACD,CAED,GAAI,CAAC,QAAQ,CAAC,IAAD,CAAb,CAAqB,CACnB,GAAI,OAAJ,CAAa,CACX,GAAI,SAAS,CAAC,IAAD,CAAb,CAAqB,CACnB,OAAO,CAAC,KAAR,mCACmC,IADnC,oQAKD,CAND,IAMO,CACL,OAAO,CAAC,KAAR,iBACiB,IADjB,+RAKD,CACF,CAED,MAAO,QAAP,CACD,CAED,kBAAmB,iBAAiB,CAAC,IAAD,CAApC,CACD,CAED,MAAM,SAAU,CAAA,QAAV,CAAmB,IAAnB,CAA+B,CACnC,MAAO,CAAA,MAAM,CAAC,cAAP,CAAsB,IAAtB,CAAP,CACD,CAED,MAAM,SAAU,CAAA,SAAV,CAAoB,IAApB,CAAgC,CACpC,MAAO,CAAA,YAAY,CAAC,cAAb,CAA4B,IAA5B,CAAP,CACD,CAED,MAAO,SAAe,CAAA,SAAf,CACL,SADK,CAEL,MAFK,0JAID,MAAO,CAAA,SAAP,GAAqB,QAJpB,2BAKG,OALH,CAKa,SALb,CAMG,KANH,CAMW,MAAM,CAAC,IAAP,CAAY,OAAZ,CANX,mDAOG,OAAO,CAAC,GAAR,CAAY,KAAK,CAAC,GAAN,CAAU,SAAA,IAAI,QAAI,CAAA,SAAS,CAAC,IAAD,CAAO,OAAO,CAAC,IAAD,CAAd,CAAb,EAAd,CAAZ,CAPH,kDAWC,IAXD,CAWQ,SAXR,KAaD,MAAM,CAAC,IAAD,CAbL,uEAiBD,YAAY,CAAC,IAAD,CAjBX,4DAkBI,YAAY,CAAC,IAAD,CAlBhB,aA0BA,MA1BA,gCA2BG,IAAI,CAAA,KAAJ,wCAAgD,IAAhD,MA3BH,SA6BC,KA7BD,CA6BS,iBAAiB,CAAC,MAAD,CA7B1B,CA8BL,YAAY,CAAC,IAAD,CAAZ,CAAsB,qMAEZ,mBAAmB,CAAC,IAAD,CAAO,KAAP,CAFP,SAGlB,MAAM,CAAC,IAAD,CAAN,CAAe,IAAf,CAHkB,uBAKlB,MAAO,CAAA,YAAY,CAAC,IAAD,CAAnB,CALkB,6FAAD,EAArB,CA9BK,mDAuCC,YAAY,CAAC,IAAD,CAvCb,kDA8CP,GAAI,MAAM,EAAI,MAAM,CAAC,OAArB,CAA8B,CAC5B,GAAI,CAAA,qBAAqB,CAAG,KAA5B,CAEA,MAAM,CAAC,cAAP,CAAsB,OAAtB,CAA+B,MAA/B,CAAuC,CACrC,GADqC,eAClC,CACD,GAAI,CAAC,qBAAL,CAA4B,CAC1B,OAAO,CAAC,IAAR,oMAGA,qBAAqB,CAAG,IAAxB,CACD,CACD,MAAO,CACL,iBAAiB,CAAjB,iBADK,CAEL,QAAQ,CAAR,QAFK,CAGL,SAAS,CAAT,SAHK,CAIL,SAAS,CAAT,SAJK,CAAP,CAMD,CAdoC,CAAvC,EAgBD","sourcesContent":["import {\n  getAssetForSource,\n  loadSingleFontAsync,\n  fontFamilyNeedsScoping,\n  getNativeFontName,\n} from './FontLoader';\n\nimport { FontSource, FontResource } from './Font.types';\n\nconst loaded: { [name: string]: boolean } = {};\nconst loadPromises: { [name: string]: Promise<void> } = {};\n\n/**\n * Used to transform font family names to the scoped name. This does not need to\n * be called in standalone or bare apps but it will return unscoped font family\n * names if it is called in those contexts.\n * note(brentvatne): at some point we may want to warn if this is called\n * outside of a managed app.\n */\nexport function processFontFamily(name: string | null): string | null {\n  if (!name || !fontFamilyNeedsScoping(name)) {\n    return name;\n  }\n\n  if (!isLoaded(name)) {\n    if (__DEV__) {\n      if (isLoading(name)) {\n        console.error(\n          `You started loading the font \"${name}\", but used it before it finished loading.\\n\n- You need to wait for Font.loadAsync to complete before using the font.\\n\n- We recommend loading all fonts before rendering the app, and rendering only Expo.AppLoading while waiting for loading to complete.`\n        );\n      } else {\n        console.error(\n          `fontFamily \"${name}\" is not a system font and has not been loaded through Font.loadAsync.\\n\n- If you intended to use a system font, make sure you typed the name correctly and that it is supported by your device operating system.\\n\n- If this is a custom font, be sure to load it with Font.loadAsync.`\n        );\n      }\n    }\n\n    return 'System';\n  }\n\n  return `ExpoFont-${getNativeFontName(name)}`;\n}\n\nexport function isLoaded(name: string): boolean {\n  return loaded.hasOwnProperty(name);\n}\n\nexport function isLoading(name: string): boolean {\n  return loadPromises.hasOwnProperty(name);\n}\n\nexport async function loadAsync(\n  nameOrMap: string | { [name: string]: FontSource },\n  source?: FontSource\n): Promise<void> {\n  if (typeof nameOrMap === 'object') {\n    const fontMap = nameOrMap;\n    const names = Object.keys(fontMap);\n    await Promise.all(names.map(name => loadAsync(name, fontMap[name])));\n    return;\n  }\n\n  const name = nameOrMap;\n\n  if (loaded[name]) {\n    return;\n  }\n\n  if (loadPromises[name]) {\n    return loadPromises[name];\n  }\n\n  // Important: we want all callers that concurrently try to load the same font to await the same\n  // promise. If we're here, we haven't created the promise yet. To ensure we create only one\n  // promise in the program, we need to create the promise synchronously without yielding the event\n  // loop from this point.\n\n  if (!source) {\n    throw new Error(`No source from which to load font \"${name}\"`);\n  }\n  const asset = getAssetForSource(source);\n  loadPromises[name] = (async () => {\n    try {\n      await loadSingleFontAsync(name, asset);\n      loaded[name] = true;\n    } finally {\n      delete loadPromises[name];\n    }\n  })();\n\n  await loadPromises[name];\n}\n\nexport { FontSource, FontResource };\n\ndeclare var module: any;\n\nif (module && module.exports) {\n  let wasImportWarningShown = false;\n  // @ts-ignore: Temporarily define an export named \"Font\" for legacy compatibility\n  Object.defineProperty(exports, 'Font', {\n    get() {\n      if (!wasImportWarningShown) {\n        console.warn(\n          `The syntax \"import { Font } from 'expo-font'\" is deprecated. Use \"import * as Font from 'expo-font'\" or import named exports instead. Support for the old syntax will be removed in SDK 33.`\n        );\n        wasImportWarningShown = true;\n      }\n      return {\n        processFontFamily,\n        isLoaded,\n        isLoading,\n        loadAsync,\n      };\n    },\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}