{"ast":null,"code":"import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _inherits from\"@babel/runtime/helpers/inherits\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import React,{Component}from'react';import invariant from'invariant';import Animated from\"react-native-web/dist/exports/Animated\";import StyleSheet from\"react-native-web/dist/exports/StyleSheet\";import View from\"react-native-web/dist/exports/View\";import Keyboard from\"react-native-web/dist/exports/Keyboard\";import StatusBar from\"react-native-web/dist/exports/StatusBar\";import I18nManager from\"react-native-web/dist/exports/I18nManager\";import{PanGestureHandler,TapGestureHandler,State}from\"./GestureHandler\";var DRAG_TOSS=0.05;var IDLE='Idle';var DRAGGING='Dragging';var SETTLING='Settling';var DrawerLayout=function(_Component){_inherits(DrawerLayout,_Component);function DrawerLayout(_props,context){var _this;_classCallCheck(this,DrawerLayout);_this=_possibleConstructorReturn(this,_getPrototypeOf(DrawerLayout).call(this,_props,context));_this._accessibilityIsModalView=React.createRef();_this._pointerEventsView=React.createRef();_this._panGestureHandler=React.createRef();_this._drawerShown=false;_this._updateAnimatedEvent=function(props,state){var drawerPosition=props.drawerPosition,drawerWidth=props.drawerWidth,drawerType=props.drawerType;var dragXValue=state.dragX,touchXValue=state.touchX,drawerTranslation=state.drawerTranslation,containerWidth=state.containerWidth;var dragX=dragXValue;var touchX=touchXValue;if(drawerPosition!=='left'){dragX=Animated.multiply(new Animated.Value(-1),dragXValue);touchX=Animated.add(new Animated.Value(containerWidth),Animated.multiply(new Animated.Value(-1),touchXValue));touchXValue.setValue(containerWidth);}else{touchXValue.setValue(0);}var translationX=dragX;if(drawerType==='front'){var startPositionX=Animated.add(touchX,Animated.multiply(new Animated.Value(-1),dragX));var dragOffsetFromOnStartPosition=startPositionX.interpolate({inputRange:[drawerWidth-1,drawerWidth,drawerWidth+1],outputRange:[0,0,1]});translationX=Animated.add(dragX,dragOffsetFromOnStartPosition);}_this._openValue=Animated.add(translationX,drawerTranslation).interpolate({inputRange:[0,drawerWidth],outputRange:[0,1],extrapolate:'clamp'});_this._onGestureEvent=Animated.event([{nativeEvent:{translationX:dragXValue,x:touchXValue}}],{useNativeDriver:props.useNativeAnimations});};_this._handleContainerLayout=function(_ref){var nativeEvent=_ref.nativeEvent;_this.setState({containerWidth:nativeEvent.layout.width});};_this._emitStateChanged=function(newState,drawerWillShow){_this.props.onDrawerStateChanged&&_this.props.onDrawerStateChanged(newState,drawerWillShow);};_this._openingHandlerStateChange=function(_ref2){var nativeEvent=_ref2.nativeEvent;if(nativeEvent.oldState===State.ACTIVE){_this._handleRelease(nativeEvent);}else if(nativeEvent.state===State.ACTIVE){_this._emitStateChanged(DRAGGING,false);if(_this.props.keyboardDismissMode==='on-drag'){Keyboard.dismiss();}if(_this.props.hideStatusBar){StatusBar.setHidden(true,_this.props.statusBarAnimation||'slide');}}};_this._onTapHandlerStateChange=function(_ref3){var nativeEvent=_ref3.nativeEvent;if(_this._drawerShown&&nativeEvent.oldState===State.ACTIVE&&_this.props.drawerLockMode!=='locked-open'){_this.closeDrawer();}};_this._handleRelease=function(nativeEvent){var _this$props=_this.props,drawerWidth=_this$props.drawerWidth,drawerPosition=_this$props.drawerPosition,drawerType=_this$props.drawerType;var containerWidth=_this.state.containerWidth;var dragX=nativeEvent.translationX,velocityX=nativeEvent.velocityX,touchX=nativeEvent.x;if(drawerPosition!=='left'){dragX=-dragX;touchX=containerWidth-touchX;velocityX=-velocityX;}var gestureStartX=touchX-dragX;var dragOffsetBasedOnStart=0;if(drawerType==='front'){dragOffsetBasedOnStart=gestureStartX>drawerWidth?gestureStartX-drawerWidth:0;}var startOffsetX=dragX+dragOffsetBasedOnStart+(_this._drawerShown?drawerWidth:0);var projOffsetX=startOffsetX+DRAG_TOSS*velocityX;var shouldOpen=projOffsetX>drawerWidth/2;if(shouldOpen){_this._animateDrawer(startOffsetX,drawerWidth,velocityX);}else{_this._animateDrawer(startOffsetX,0,velocityX);}};_this._updateShowing=function(showing){_this._drawerShown=showing;_this._accessibilityIsModalView.current&&_this._accessibilityIsModalView.current.setNativeProps({accessibilityViewIsModal:showing});_this._pointerEventsView.current&&_this._pointerEventsView.current.setNativeProps({pointerEvents:showing?'auto':'none'});var _this$props2=_this.props,drawerPosition=_this$props2.drawerPosition,minSwipeDistance=_this$props2.minSwipeDistance,edgeWidth=_this$props2.edgeWidth;var fromLeft=drawerPosition==='left';var gestureOrientation=(fromLeft?1:-1)*(_this._drawerShown?-1:1);var hitSlop=fromLeft?{left:0,width:showing?undefined:edgeWidth}:{right:0,width:showing?undefined:edgeWidth};_this._panGestureHandler.current&&_this._panGestureHandler.current.setNativeProps({hitSlop:hitSlop,activeOffsetX:gestureOrientation*minSwipeDistance});};_this._animateDrawer=function(fromValue,toValue,velocity){_this.state.dragX.setValue(0);_this.state.touchX.setValue(_this.props.drawerPosition==='left'?0:_this.state.containerWidth);if(fromValue!=null){var nextFramePosition=fromValue;if(_this.props.useNativeAnimations){if(fromValue<toValue&&velocity>0){nextFramePosition=Math.min(fromValue+velocity/60.0,toValue);}else if(fromValue>toValue&&velocity<0){nextFramePosition=Math.max(fromValue+velocity/60.0,toValue);}}_this.state.drawerTranslation.setValue(nextFramePosition);}var willShow=toValue!==0;_this._updateShowing(willShow);_this._emitStateChanged(SETTLING,willShow);if(_this.props.hideStatusBar){StatusBar.setHidden(willShow,_this.props.statusBarAnimation||'slide');}Animated.spring(_this.state.drawerTranslation,{velocity:velocity,bounciness:0,toValue:toValue,useNativeDriver:_this.props.useNativeAnimations}).start(function(_ref4){var finished=_ref4.finished;if(finished){_this._emitStateChanged(IDLE,willShow);if(willShow){_this.props.onDrawerOpen&&_this.props.onDrawerOpen();}else{_this.props.onDrawerClose&&_this.props.onDrawerClose();}}});};_this.openDrawer=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_this._animateDrawer(undefined,_this.props.drawerWidth,options.velocity?options.velocity:0);_this.forceUpdate();};_this.closeDrawer=function(){var options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};_this._animateDrawer(undefined,0,options.velocity?options.velocity:0);_this.forceUpdate();};_this._renderOverlay=function(){invariant(_this._openValue,'should be set');var overlayOpacity=_this._openValue.interpolate({inputRange:[0,1],outputRange:[0,1],extrapolate:'clamp'});var dynamicOverlayStyles={opacity:overlayOpacity,backgroundColor:_this.props.overlayColor};return React.createElement(TapGestureHandler,{onHandlerStateChange:_this._onTapHandlerStateChange},React.createElement(Animated.View,{pointerEvents:_this._drawerShown?'auto':'none',ref:_this._pointerEventsView,style:[styles.overlay,dynamicOverlayStyles]}));};_this._renderDrawer=function(){var _this$props3=_this.props,drawerBackgroundColor=_this$props3.drawerBackgroundColor,drawerWidth=_this$props3.drawerWidth,drawerPosition=_this$props3.drawerPosition,drawerType=_this$props3.drawerType,drawerContainerStyle=_this$props3.drawerContainerStyle,contentContainerStyle=_this$props3.contentContainerStyle;var fromLeft=drawerPosition==='left';var drawerSlide=drawerType!=='back';var containerSlide=drawerType!=='front';var reverseContentDirection=I18nManager.isRTL?fromLeft:!fromLeft;var dynamicDrawerStyles={backgroundColor:drawerBackgroundColor,width:drawerWidth};var openValue=_this._openValue;invariant(openValue,'should be set');var containerStyles;if(containerSlide){var containerTranslateX=openValue.interpolate({inputRange:[0,1],outputRange:fromLeft?[0,drawerWidth]:[0,-drawerWidth],extrapolate:'clamp'});containerStyles={transform:[{translateX:containerTranslateX}]};}var drawerTranslateX=0;if(drawerSlide){var closedDrawerOffset=fromLeft?-drawerWidth:drawerWidth;drawerTranslateX=openValue.interpolate({inputRange:[0,1],outputRange:[closedDrawerOffset,0],extrapolate:'clamp'});}var drawerStyles={transform:[{translateX:drawerTranslateX}],flexDirection:reverseContentDirection?'row-reverse':'row'};return React.createElement(Animated.View,{style:styles.main,onLayout:_this._handleContainerLayout},React.createElement(Animated.View,{style:[drawerType==='front'?styles.containerOnBack:styles.containerInFront,containerStyles,contentContainerStyle],importantForAccessibility:_this._drawerShown?'no-hide-descendants':'yes'},typeof _this.props.children==='function'?_this.props.children(_this._openValue):_this.props.children,_this._renderOverlay()),React.createElement(Animated.View,{pointerEvents:\"box-none\",ref:_this._accessibilityIsModalView,accessibilityViewIsModal:_this._drawerShown,style:[styles.drawerContainer,drawerStyles,drawerContainerStyle]},React.createElement(View,{style:dynamicDrawerStyles},_this.props.renderNavigationView(_this._openValue))));};_this._setPanGestureRef=function(ref){_this._panGestureHandler.current=ref;_this.props.onGestureRef&&_this.props.onGestureRef(ref);};var _dragX=new Animated.Value(0);var _touchX=new Animated.Value(0);var _drawerTranslation=new Animated.Value(0);_this.state={dragX:_dragX,touchX:_touchX,drawerTranslation:_drawerTranslation,containerWidth:0};_this._updateAnimatedEvent(_props,_this.state);return _this;}_createClass(DrawerLayout,[{key:\"UNSAFE_componentWillUpdate\",value:function UNSAFE_componentWillUpdate(props,state){if(this.props.drawerPosition!==props.drawerPosition||this.props.drawerWidth!==props.drawerWidth||this.props.drawerType!==props.drawerType||this.state.containerWidth!==state.containerWidth){this._updateAnimatedEvent(props,state);}}},{key:\"render\",value:function render(){var _this$props4=this.props,drawerPosition=_this$props4.drawerPosition,drawerLockMode=_this$props4.drawerLockMode,edgeWidth=_this$props4.edgeWidth,minSwipeDistance=_this$props4.minSwipeDistance;var fromLeft=drawerPosition==='left';var gestureOrientation=(fromLeft?1:-1)*(this._drawerShown?-1:1);var hitSlop=fromLeft?{left:0,width:this._drawerShown?undefined:edgeWidth}:{right:0,width:this._drawerShown?undefined:edgeWidth};return React.createElement(PanGestureHandler,{ref:this._setPanGestureRef,hitSlop:hitSlop,activeOffsetX:gestureOrientation*minSwipeDistance,failOffsetY:[-15,15],onGestureEvent:this._onGestureEvent,onHandlerStateChange:this._openingHandlerStateChange,enabled:drawerLockMode!=='locked-closed'&&drawerLockMode!=='locked-open'},this._renderDrawer());}}]);return DrawerLayout;}(Component);DrawerLayout.defaultProps={drawerWidth:200,drawerPosition:'left',useNativeAnimations:true,drawerType:'front',edgeWidth:20,minSwipeDistance:3,overlayColor:'rgba(0, 0, 0, 0.7)',drawerLockMode:'unlocked'};DrawerLayout.positions={Left:'left',Right:'right'};export{DrawerLayout as default};var styles=StyleSheet.create({drawerContainer:_objectSpread({},StyleSheet.absoluteFillObject,{zIndex:1001,flexDirection:'row'}),containerInFront:_objectSpread({},StyleSheet.absoluteFillObject,{zIndex:1002}),containerOnBack:_objectSpread({},StyleSheet.absoluteFillObject),main:{flex:1,zIndex:0,overflow:'hidden'},overlay:_objectSpread({},StyleSheet.absoluteFillObject,{zIndex:1000})});","map":{"version":3,"sources":["C:/Users/karth/Documents/RoboticsScoutingTool/node_modules/react-native-gesture-handler/DrawerLayout.js"],"names":["React","Component","invariant","PanGestureHandler","TapGestureHandler","State","DRAG_TOSS","IDLE","DRAGGING","SETTLING","DrawerLayout","props","context","_accessibilityIsModalView","createRef","_pointerEventsView","_panGestureHandler","_drawerShown","_updateAnimatedEvent","state","drawerPosition","drawerWidth","drawerType","dragXValue","dragX","touchXValue","touchX","drawerTranslation","containerWidth","Animated","multiply","Value","add","setValue","translationX","startPositionX","dragOffsetFromOnStartPosition","interpolate","inputRange","outputRange","_openValue","extrapolate","_onGestureEvent","event","nativeEvent","x","useNativeDriver","useNativeAnimations","_handleContainerLayout","setState","layout","width","_emitStateChanged","newState","drawerWillShow","onDrawerStateChanged","_openingHandlerStateChange","oldState","ACTIVE","_handleRelease","keyboardDismissMode","Keyboard","dismiss","hideStatusBar","StatusBar","setHidden","statusBarAnimation","_onTapHandlerStateChange","drawerLockMode","closeDrawer","velocityX","gestureStartX","dragOffsetBasedOnStart","startOffsetX","projOffsetX","shouldOpen","_animateDrawer","_updateShowing","showing","current","setNativeProps","accessibilityViewIsModal","pointerEvents","minSwipeDistance","edgeWidth","fromLeft","gestureOrientation","hitSlop","left","undefined","right","activeOffsetX","fromValue","toValue","velocity","nextFramePosition","Math","min","max","willShow","spring","bounciness","start","finished","onDrawerOpen","onDrawerClose","openDrawer","options","forceUpdate","_renderOverlay","overlayOpacity","dynamicOverlayStyles","opacity","backgroundColor","overlayColor","styles","overlay","_renderDrawer","drawerBackgroundColor","drawerContainerStyle","contentContainerStyle","drawerSlide","containerSlide","reverseContentDirection","I18nManager","isRTL","dynamicDrawerStyles","openValue","containerStyles","containerTranslateX","transform","translateX","drawerTranslateX","closedDrawerOffset","drawerStyles","flexDirection","main","containerOnBack","containerInFront","children","drawerContainer","renderNavigationView","_setPanGestureRef","ref","onGestureRef","defaultProps","positions","Left","Right","StyleSheet","create","absoluteFillObject","zIndex","flex","overflow"],"mappings":"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","sourcesContent":["// @flow\n\n// This component is based on RN's DrawerLayoutAndroid API\n//\n// It perhaps deserves to be put in a separate repo, but since it relies\n// on react-native-gesture-handler library which isn't very popular at the\n// moment I decided to keep it here for the time being. It will allow us\n// to move faster and fix issues that may arise in gesture handler library\n// that could be found when using the drawer component\n\nimport React, { Component } from 'react';\nimport invariant from 'invariant';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  Keyboard,\n  StatusBar,\n  I18nManager,\n} from 'react-native';\n\nimport { PanGestureHandler, TapGestureHandler, State } from './GestureHandler';\n\nconst DRAG_TOSS = 0.05;\n\nconst IDLE = 'Idle';\nconst DRAGGING = 'Dragging';\nconst SETTLING = 'Settling';\n\nexport type PropType = {\n  children: any,\n  drawerBackgroundColor?: string,\n  drawerPosition: 'left' | 'right',\n  drawerLockMode?: 'unlocked' | 'locked-closed' | 'locked-open',\n  drawerWidth: number,\n  keyboardDismissMode?: 'none' | 'on-drag',\n  onDrawerClose?: Function,\n  onDrawerOpen?: Function,\n  onDrawerStateChanged?: Function,\n  renderNavigationView: (progressAnimatedValue: any) => any,\n  useNativeAnimations: boolean,\n\n  // brand new properties\n  drawerType: 'front' | 'back' | 'slide',\n  edgeWidth: number,\n  minSwipeDistance: number,\n  hideStatusBar?: boolean,\n  statusBarAnimation?: 'slide' | 'none' | 'fade',\n  overlayColor: string,\n  drawerContainerStyle?: any,\n  contentContainerStyle?: any,\n  onGestureRef?: Function,\n\n  // Properties not yet supported\n  // onDrawerSlide?: Function\n};\n\nexport type StateType = {\n  dragX: any,\n  touchX: any,\n  drawerTranslation: any,\n  containerWidth: number,\n};\n\nexport type EventType = {\n  stopPropagation: Function,\n};\n\nexport type DrawerMovementOptionType = {\n  velocity?: number,\n};\n\nexport default class DrawerLayout extends Component<PropType, StateType> {\n  static defaultProps = {\n    drawerWidth: 200,\n    drawerPosition: 'left',\n    useNativeAnimations: true,\n    drawerType: 'front',\n    edgeWidth: 20,\n    minSwipeDistance: 3,\n    overlayColor: 'rgba(0, 0, 0, 0.7)',\n    drawerLockMode: 'unlocked',\n  };\n\n  static positions = {\n    Left: 'left',\n    Right: 'right',\n  };\n  _openValue: ?Animated.Interpolation;\n  _onGestureEvent: ?Animated.Event;\n  _accessibilityIsModalView = React.createRef();\n  _pointerEventsView = React.createRef();\n  _panGestureHandler = React.createRef();\n  _drawerShown = false;\n\n  constructor(props: PropType, context: any) {\n    super(props, context);\n\n    const dragX = new Animated.Value(0);\n    const touchX = new Animated.Value(0);\n    const drawerTranslation = new Animated.Value(0);\n\n    this.state = {\n      dragX,\n      touchX,\n      drawerTranslation,\n      containerWidth: 0,\n    };\n\n    this._updateAnimatedEvent(props, this.state);\n  }\n\n  UNSAFE_componentWillUpdate(props: PropType, state: StateType) {\n    if (\n      this.props.drawerPosition !== props.drawerPosition ||\n      this.props.drawerWidth !== props.drawerWidth ||\n      this.props.drawerType !== props.drawerType ||\n      this.state.containerWidth !== state.containerWidth\n    ) {\n      this._updateAnimatedEvent(props, state);\n    }\n  }\n\n  _updateAnimatedEvent = (props: PropType, state: StateType) => {\n    // Event definition is based on\n    const { drawerPosition, drawerWidth, drawerType } = props;\n    const {\n      dragX: dragXValue,\n      touchX: touchXValue,\n      drawerTranslation,\n      containerWidth,\n    } = state;\n\n    let dragX = dragXValue;\n    let touchX = touchXValue;\n\n    if (drawerPosition !== 'left') {\n      // Most of the code is written in a way to handle left-side drawer.\n      // In order to handle right-side drawer the only thing we need to\n      // do is to reverse events coming from gesture handler in a way they\n      // emulate left-side drawer gestures. E.g. dragX is simply -dragX, and\n      // touchX is calulcated by subtracing real touchX from the width of the\n      // container (such that when touch happens at the right edge the value\n      // is simply 0)\n      dragX = Animated.multiply(new Animated.Value(-1), dragXValue);\n      touchX = Animated.add(\n        new Animated.Value(containerWidth),\n        Animated.multiply(new Animated.Value(-1), touchXValue)\n      );\n      touchXValue.setValue(containerWidth);\n    } else {\n      touchXValue.setValue(0);\n    }\n\n    // While closing the drawer when user starts gesture outside of its area (in greyed\n    // out part of the window), we want the drawer to follow only once finger reaches the\n    // edge of the drawer.\n    // E.g. on the diagram below drawer is illustrate by X signs and the greyed out area by\n    // dots. The touch gesture starts at '*' and moves left, touch path is indicated by\n    // an arrow pointing left\n    // 1) +---------------+ 2) +---------------+ 3) +---------------+ 4) +---------------+\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|.<-*..|    |XXXXXXXX|<--*..|    |XXXXX|<-----*..|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXXXXX|......|    |XXXXX|.........|\n    //    +---------------+    +---------------+    +---------------+    +---------------+\n    //\n    // For the above to work properly we define animated value that will keep start position\n    // of the gesture. Then we use that value to calculate how much we need to subtract from\n    // the dragX. If the gesture started on the greyed out area we take the distance from the\n    // edge of the drawer to the start position. Otherwise we don't subtract at all and the\n    // drawer be pulled back as soon as you start the pan.\n    //\n    // This is used only when drawerType is \"front\"\n    //\n    let translationX = dragX;\n    if (drawerType === 'front') {\n      const startPositionX = Animated.add(\n        touchX,\n        Animated.multiply(new Animated.Value(-1), dragX)\n      );\n\n      const dragOffsetFromOnStartPosition = startPositionX.interpolate({\n        inputRange: [drawerWidth - 1, drawerWidth, drawerWidth + 1],\n        outputRange: [0, 0, 1],\n      });\n      translationX = Animated.add(dragX, dragOffsetFromOnStartPosition);\n    }\n\n    this._openValue = Animated.add(translationX, drawerTranslation).interpolate(\n      {\n        inputRange: [0, drawerWidth],\n        outputRange: [0, 1],\n        extrapolate: 'clamp',\n      }\n    );\n\n    this._onGestureEvent = Animated.event(\n      [{ nativeEvent: { translationX: dragXValue, x: touchXValue } }],\n      { useNativeDriver: props.useNativeAnimations }\n    );\n  };\n\n  _handleContainerLayout = ({ nativeEvent }) => {\n    this.setState({ containerWidth: nativeEvent.layout.width });\n  };\n\n  _emitStateChanged = (newState: string, drawerWillShow: boolean) => {\n    this.props.onDrawerStateChanged &&\n      this.props.onDrawerStateChanged(newState, drawerWillShow);\n  };\n\n  _openingHandlerStateChange = ({ nativeEvent }) => {\n    if (nativeEvent.oldState === State.ACTIVE) {\n      this._handleRelease(nativeEvent);\n    } else if (nativeEvent.state === State.ACTIVE) {\n      this._emitStateChanged(DRAGGING, false);\n      if (this.props.keyboardDismissMode === 'on-drag') {\n        Keyboard.dismiss();\n      }\n      if (this.props.hideStatusBar) {\n        StatusBar.setHidden(true, this.props.statusBarAnimation || 'slide');\n      }\n    }\n  };\n\n  _onTapHandlerStateChange = ({ nativeEvent }) => {\n    if (\n      this._drawerShown &&\n      nativeEvent.oldState === State.ACTIVE &&\n      this.props.drawerLockMode !== 'locked-open'\n    ) {\n      this.closeDrawer();\n    }\n  };\n\n  _handleRelease = nativeEvent => {\n    const { drawerWidth, drawerPosition, drawerType } = this.props;\n    const { containerWidth } = this.state;\n    let { translationX: dragX, velocityX, x: touchX } = nativeEvent;\n\n    if (drawerPosition !== 'left') {\n      // See description in _updateAnimatedEvent about why events are flipped\n      // for right-side drawer\n      dragX = -dragX;\n      touchX = containerWidth - touchX;\n      velocityX = -velocityX;\n    }\n\n    const gestureStartX = touchX - dragX;\n    let dragOffsetBasedOnStart = 0;\n\n    if (drawerType === 'front') {\n      dragOffsetBasedOnStart =\n        gestureStartX > drawerWidth ? gestureStartX - drawerWidth : 0;\n    }\n\n    const startOffsetX =\n      dragX + dragOffsetBasedOnStart + (this._drawerShown ? drawerWidth : 0);\n    const projOffsetX = startOffsetX + DRAG_TOSS * velocityX;\n\n    const shouldOpen = projOffsetX > drawerWidth / 2;\n\n    if (shouldOpen) {\n      this._animateDrawer(startOffsetX, drawerWidth, velocityX);\n    } else {\n      this._animateDrawer(startOffsetX, 0, velocityX);\n    }\n  };\n\n  _updateShowing = (showing: boolean) => {\n    this._drawerShown = showing;\n    this._accessibilityIsModalView.current &&\n      this._accessibilityIsModalView.current.setNativeProps({\n        accessibilityViewIsModal: showing,\n      });\n    this._pointerEventsView.current &&\n      this._pointerEventsView.current.setNativeProps({\n        pointerEvents: showing ? 'auto' : 'none',\n      });\n    const { drawerPosition, minSwipeDistance, edgeWidth } = this.props;\n    const fromLeft = drawerPosition === 'left';\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: showing ? undefined : edgeWidth }\n      : { right: 0, width: showing ? undefined : edgeWidth };\n    this._panGestureHandler.current &&\n      this._panGestureHandler.current.setNativeProps({\n        hitSlop,\n        activeOffsetX: gestureOrientation * minSwipeDistance,\n      });\n  };\n\n  _animateDrawer = (fromValue: ?number, toValue: number, velocity: number) => {\n    this.state.dragX.setValue(0);\n    this.state.touchX.setValue(\n      this.props.drawerPosition === 'left' ? 0 : this.state.containerWidth\n    );\n\n    if (fromValue != null) {\n      let nextFramePosition = fromValue;\n      if (this.props.useNativeAnimations) {\n        // When using native driver, we predict the next position of the animation\n        // because it takes one frame of a roundtrip to pass RELEASE event from\n        // native driver to JS before we can start animating. Without it, it is more\n        // noticable that the frame is dropped.\n        if (fromValue < toValue && velocity > 0) {\n          nextFramePosition = Math.min(fromValue + velocity / 60.0, toValue);\n        } else if (fromValue > toValue && velocity < 0) {\n          nextFramePosition = Math.max(fromValue + velocity / 60.0, toValue);\n        }\n      }\n      this.state.drawerTranslation.setValue(nextFramePosition);\n    }\n\n    const willShow = toValue !== 0;\n    this._updateShowing(willShow);\n    this._emitStateChanged(SETTLING, willShow);\n    if (this.props.hideStatusBar) {\n      StatusBar.setHidden(willShow, this.props.statusBarAnimation || 'slide');\n    }\n    Animated.spring(this.state.drawerTranslation, {\n      velocity,\n      bounciness: 0,\n      toValue,\n      useNativeDriver: this.props.useNativeAnimations,\n    }).start(({ finished }) => {\n      if (finished) {\n        this._emitStateChanged(IDLE, willShow);\n        if (willShow) {\n          this.props.onDrawerOpen && this.props.onDrawerOpen();\n        } else {\n          this.props.onDrawerClose && this.props.onDrawerClose();\n        }\n      }\n    });\n  };\n\n  openDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(\n      undefined,\n      this.props.drawerWidth,\n      options.velocity ? options.velocity : 0\n    );\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would not be clickable\n    this.forceUpdate();\n  };\n\n  closeDrawer = (options: DrawerMovementOptionType = {}) => {\n    this._animateDrawer(undefined, 0, options.velocity ? options.velocity : 0);\n\n    // We need to force the update, otherwise the overlay is not rerendered and it would be still clickable\n    this.forceUpdate();\n  };\n\n  _renderOverlay = () => {\n    /* Overlay styles */\n    invariant(this._openValue, 'should be set');\n    const overlayOpacity = this._openValue.interpolate({\n      inputRange: [0, 1],\n      outputRange: [0, 1],\n      extrapolate: 'clamp',\n    });\n    const dynamicOverlayStyles = {\n      opacity: overlayOpacity,\n      backgroundColor: this.props.overlayColor,\n    };\n\n    return (\n      <TapGestureHandler onHandlerStateChange={this._onTapHandlerStateChange}>\n        <Animated.View\n          pointerEvents={this._drawerShown ? 'auto' : 'none'}\n          ref={this._pointerEventsView}\n          style={[styles.overlay, dynamicOverlayStyles]}\n        />\n      </TapGestureHandler>\n    );\n  };\n\n  _renderDrawer = () => {\n    const {\n      drawerBackgroundColor,\n      drawerWidth,\n      drawerPosition,\n      drawerType,\n      drawerContainerStyle,\n      contentContainerStyle,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n    const drawerSlide = drawerType !== 'back';\n    const containerSlide = drawerType !== 'front';\n\n    // we rely on row and row-reverse flex directions to position the drawer\n    // properly. Apparently for RTL these are flipped which requires us to use\n    // the opposite setting for the drawer to appear from left or right according\n    // to the drawerPosition prop\n    const reverseContentDirection = I18nManager.isRTL ? fromLeft : !fromLeft;\n\n    const dynamicDrawerStyles = {\n      backgroundColor: drawerBackgroundColor,\n      width: drawerWidth,\n    };\n    const openValue = this._openValue;\n    invariant(openValue, 'should be set');\n\n    let containerStyles;\n    if (containerSlide) {\n      const containerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: fromLeft ? [0, drawerWidth] : [0, -drawerWidth],\n        extrapolate: 'clamp',\n      });\n      containerStyles = {\n        transform: [{ translateX: containerTranslateX }],\n      };\n    }\n\n    let drawerTranslateX = 0;\n    if (drawerSlide) {\n      const closedDrawerOffset = fromLeft ? -drawerWidth : drawerWidth;\n      drawerTranslateX = openValue.interpolate({\n        inputRange: [0, 1],\n        outputRange: [closedDrawerOffset, 0],\n        extrapolate: 'clamp',\n      });\n    }\n    const drawerStyles = {\n      transform: [{ translateX: drawerTranslateX }],\n      flexDirection: reverseContentDirection ? 'row-reverse' : 'row',\n    };\n\n    return (\n      <Animated.View style={styles.main} onLayout={this._handleContainerLayout}>\n        <Animated.View\n          style={[\n            drawerType === 'front'\n              ? styles.containerOnBack\n              : styles.containerInFront,\n            containerStyles,\n            contentContainerStyle,\n          ]}\n          importantForAccessibility={\n            this._drawerShown ? 'no-hide-descendants' : 'yes'\n          }>\n          {typeof this.props.children === 'function'\n            ? this.props.children(this._openValue)\n            : this.props.children}\n          {this._renderOverlay()}\n        </Animated.View>\n        <Animated.View\n          pointerEvents=\"box-none\"\n          ref={this._accessibilityIsModalView}\n          accessibilityViewIsModal={this._drawerShown}\n          style={[styles.drawerContainer, drawerStyles, drawerContainerStyle]}>\n          <View style={dynamicDrawerStyles}>\n            {this.props.renderNavigationView(this._openValue)}\n          </View>\n        </Animated.View>\n      </Animated.View>\n    );\n  };\n\n  _setPanGestureRef = ref => {\n    this._panGestureHandler.current = ref;\n    this.props.onGestureRef && this.props.onGestureRef(ref);\n  };\n\n  render() {\n    const {\n      drawerPosition,\n      drawerLockMode,\n      edgeWidth,\n      minSwipeDistance,\n    } = this.props;\n\n    const fromLeft = drawerPosition === 'left';\n\n    // gestureOrientation is 1 if the expected gesture is from left to right and -1 otherwise\n    // e.g. when drawer is on the left and is closed we expect left to right gesture, thus\n    // orientation will be 1.\n    const gestureOrientation =\n      (fromLeft ? 1 : -1) * (this._drawerShown ? -1 : 1);\n\n    // When drawer is closed we want the hitSlop to be horizontally shorter\n    // than the container size by the value of SLOP. This will make it only\n    // activate when gesture happens not further than SLOP away from the edge\n    const hitSlop = fromLeft\n      ? { left: 0, width: this._drawerShown ? undefined : edgeWidth }\n      : { right: 0, width: this._drawerShown ? undefined : edgeWidth };\n\n    return (\n      <PanGestureHandler\n        ref={this._setPanGestureRef}\n        hitSlop={hitSlop}\n        activeOffsetX={gestureOrientation * minSwipeDistance}\n        failOffsetY={[-15, 15]}\n        onGestureEvent={this._onGestureEvent}\n        onHandlerStateChange={this._openingHandlerStateChange}\n        enabled={\n          drawerLockMode !== 'locked-closed' && drawerLockMode !== 'locked-open'\n        }>\n        {this._renderDrawer()}\n      </PanGestureHandler>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  drawerContainer: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1001,\n    flexDirection: 'row',\n  },\n  containerInFront: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1002,\n  },\n  containerOnBack: {\n    ...StyleSheet.absoluteFillObject,\n  },\n  main: {\n    flex: 1,\n    zIndex: 0,\n    overflow: 'hidden',\n  },\n  overlay: {\n    ...StyleSheet.absoluteFillObject,\n    zIndex: 1000,\n  },\n});\n"]},"metadata":{},"sourceType":"module"}