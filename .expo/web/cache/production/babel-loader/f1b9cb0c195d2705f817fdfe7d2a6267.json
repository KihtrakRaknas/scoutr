{"ast":null,"code":"import _objectWithoutProperties from\"@babel/runtime/helpers/objectWithoutProperties\";import _defineProperty from\"@babel/runtime/helpers/defineProperty\";import _classCallCheck from\"@babel/runtime/helpers/classCallCheck\";import _createClass from\"@babel/runtime/helpers/createClass\";import _possibleConstructorReturn from\"@babel/runtime/helpers/possibleConstructorReturn\";import _getPrototypeOf from\"@babel/runtime/helpers/getPrototypeOf\";import _get from\"@babel/runtime/helpers/get\";import _inherits from\"@babel/runtime/helpers/inherits\";function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}import Hammer from'hammerjs';import DiscreteGestureHandler from\"./DiscreteGestureHandler\";import{isnan}from\"./utils\";var TapGestureHandler=function(_DiscreteGestureHandl){_inherits(TapGestureHandler,_DiscreteGestureHandl);function TapGestureHandler(){var _getPrototypeOf2;var _this;_classCallCheck(this,TapGestureHandler);for(var _len=arguments.length,args=new Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}_this=_possibleConstructorReturn(this,(_getPrototypeOf2=_getPrototypeOf(TapGestureHandler)).call.apply(_getPrototypeOf2,[this].concat(args)));_this.onSuccessfulTap=function(ev){if(_this._getPendingGestures().length){_this._shouldFireEndEvent=ev;return;}if(ev.eventType===Hammer.INPUT_END){_this.sendEvent(_objectSpread({},ev,{eventType:Hammer.INPUT_MOVE}));}_this.sendEvent(_objectSpread({},ev,{isFinal:true}));_this.onGestureEnded(ev);};return _this;}_createClass(TapGestureHandler,[{key:\"simulateCancelEvent\",value:function simulateCancelEvent(inputData){if(this.isGestureRunning){this.cancelEvent(inputData);}}},{key:\"onGestureActivated\",value:function onGestureActivated(ev){if(this.isGestureRunning){this.onSuccessfulTap(ev);}}},{key:\"onRawEvent\",value:function onRawEvent(ev){var _this2=this;_get(_getPrototypeOf(TapGestureHandler.prototype),\"onRawEvent\",this).call(this,ev);if(!this.hasGestureFailed&&!this.isGestureRunning&&!ev.isFinal){var gesture=this.hammer.get(this.name);if(gesture.options.enable(gesture,ev)){clearTimeout(this._multiTapTimer);this.onStart(ev);this.sendEvent(ev);}}if(ev.isFinal&&ev.maxPointers>1){setTimeout(function(){if(_this2.isGestureRunning){_this2.cancelEvent(ev);}});}if(this.hasGestureFailed){return;}if(ev.isFinal){if(ev.maxPointers>1){setTimeout(function(){if(_this2.isGestureRunning){_this2.cancelEvent(ev);}});}clearTimeout(this._timer);this._timer=setTimeout(function(){_this2.hasGestureFailed=true;_this2.cancelEvent(ev);},this.maxDelayMs);}else if(!this.hasGestureFailed&&!this.isGestureRunning){var _gesture=this.hammer.get(this.name);if(_gesture.options.enable(_gesture,ev)){clearTimeout(this._multiTapTimer);this.onStart(ev);this.sendEvent(ev);}}}},{key:\"getHammerConfig\",value:function getHammerConfig(){return _objectSpread({},_get(_getPrototypeOf(TapGestureHandler.prototype),\"getHammerConfig\",this).call(this),{event:this.name,taps:isnan(this.config.numberOfTaps)?1:this.config.numberOfTaps,interval:this.maxDelayMs,time:isnan(this.config.maxDurationMs)||this.config.maxDurationMs==null?250:this.config.maxDurationMs});}},{key:\"updateGestureConfig\",value:function updateGestureConfig(_ref){var _ref$shouldCancelWhen=_ref.shouldCancelWhenOutside,shouldCancelWhenOutside=_ref$shouldCancelWhen===void 0?true:_ref$shouldCancelWhen,_ref$maxDeltaX=_ref.maxDeltaX,maxDeltaX=_ref$maxDeltaX===void 0?Number.NaN:_ref$maxDeltaX,_ref$maxDeltaY=_ref.maxDeltaY,maxDeltaY=_ref$maxDeltaY===void 0?Number.NaN:_ref$maxDeltaY,_ref$numberOfTaps=_ref.numberOfTaps,numberOfTaps=_ref$numberOfTaps===void 0?1:_ref$numberOfTaps,_ref$minDurationMs=_ref.minDurationMs,minDurationMs=_ref$minDurationMs===void 0?525:_ref$minDurationMs,_ref$maxDelayMs=_ref.maxDelayMs,maxDelayMs=_ref$maxDelayMs===void 0?Number.NaN:_ref$maxDelayMs,_ref$maxDurationMs=_ref.maxDurationMs,maxDurationMs=_ref$maxDurationMs===void 0?Number.NaN:_ref$maxDurationMs,_ref$maxDist=_ref.maxDist,maxDist=_ref$maxDist===void 0?2:_ref$maxDist,_ref$minPointers=_ref.minPointers,minPointers=_ref$minPointers===void 0?1:_ref$minPointers,_ref$maxPointers=_ref.maxPointers,maxPointers=_ref$maxPointers===void 0?1:_ref$maxPointers,props=_objectWithoutProperties(_ref,[\"shouldCancelWhenOutside\",\"maxDeltaX\",\"maxDeltaY\",\"numberOfTaps\",\"minDurationMs\",\"maxDelayMs\",\"maxDurationMs\",\"maxDist\",\"minPointers\",\"maxPointers\"]);return _get(_getPrototypeOf(TapGestureHandler.prototype),\"updateGestureConfig\",this).call(this,_objectSpread({shouldCancelWhenOutside:shouldCancelWhenOutside,numberOfTaps:numberOfTaps,maxDeltaX:maxDeltaX,maxDeltaY:maxDeltaY,minDurationMs:minDurationMs,maxDelayMs:maxDelayMs,maxDist:maxDist,minPointers:minPointers,maxPointers:maxPointers},props));}},{key:\"onGestureEnded\",value:function onGestureEnded(){var _get2;clearTimeout(this._timer);for(var _len2=arguments.length,props=new Array(_len2),_key2=0;_key2<_len2;_key2++){props[_key2]=arguments[_key2];}(_get2=_get(_getPrototypeOf(TapGestureHandler.prototype),\"onGestureEnded\",this)).call.apply(_get2,[this].concat(props));}},{key:\"onWaitingEnded\",value:function onWaitingEnded(gesture){if(this._shouldFireEndEvent){this.onSuccessfulTap(this._shouldFireEndEvent);this._shouldFireEndEvent=null;}}},{key:\"name\",get:function get(){return'tap';}},{key:\"NativeGestureClass\",get:function get(){return Hammer.Tap;}},{key:\"maxDelayMs\",get:function get(){return isnan(this.config.maxDelayMs)?300:this.config.maxDelayMs;}}]);return TapGestureHandler;}(DiscreteGestureHandler);export default TapGestureHandler;","map":{"version":3,"sources":["C:/Users/karth/Documents/RoboticsScoutingTool/node_modules/react-native-gesture-handler/web/TapGestureHandler.js"],"names":["Hammer","DiscreteGestureHandler","isnan","TapGestureHandler","onSuccessfulTap","ev","_getPendingGestures","length","_shouldFireEndEvent","eventType","INPUT_END","sendEvent","INPUT_MOVE","isFinal","onGestureEnded","inputData","isGestureRunning","cancelEvent","hasGestureFailed","gesture","hammer","get","name","options","enable","clearTimeout","_multiTapTimer","onStart","maxPointers","setTimeout","_timer","maxDelayMs","event","taps","config","numberOfTaps","interval","time","maxDurationMs","shouldCancelWhenOutside","maxDeltaX","Number","NaN","maxDeltaY","minDurationMs","maxDist","minPointers","props","Tap"],"mappings":"ozCAAA,MAAOA,CAAAA,MAAP,KAAmB,UAAnB,CAEA,MAAOC,CAAAA,sBAAP,gCACA,OAASC,KAAT,e,GAEMC,CAAAA,iB,obAyBJC,e,CAAkB,SAAAC,EAAE,CAAI,CACtB,GAAI,MAAKC,mBAAL,GAA2BC,MAA/B,CAAuC,CACrC,MAAKC,mBAAL,CAA2BH,EAA3B,CACA,OACD,CACD,GAAIA,EAAE,CAACI,SAAH,GAAiBT,MAAM,CAACU,SAA5B,CAAuC,CACrC,MAAKC,SAAL,kBAAoBN,EAApB,EAAwBI,SAAS,CAAET,MAAM,CAACY,UAA1C,IACD,CAED,MAAKD,SAAL,kBAAoBN,EAApB,EAAwBQ,OAAO,CAAE,IAAjC,IACA,MAAKC,cAAL,CAAoBT,EAApB,EACD,C,6GAvBmBU,S,CAAW,CAC7B,GAAI,KAAKC,gBAAT,CAA2B,CACzB,KAAKC,WAAL,CAAiBF,SAAjB,EACD,CACF,C,8DAEkBV,E,CAAI,CACrB,GAAI,KAAKW,gBAAT,CAA2B,CACzB,KAAKZ,eAAL,CAAqBC,EAArB,EACD,CACF,C,8CAeUA,E,CAAI,iBACb,+EAAiBA,EAAjB,EAGA,GACE,CAAC,KAAKa,gBAAN,EACA,CAAC,KAAKF,gBADN,EAGA,CAACX,EAAE,CAACQ,OAJN,CAKE,CAEA,GAAMM,CAAAA,OAAO,CAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgB,KAAKC,IAArB,CAAhB,CACA,GAAIH,OAAO,CAACI,OAAR,CAAgBC,MAAhB,CAAuBL,OAAvB,CAAgCd,EAAhC,CAAJ,CAAyC,CACvCoB,YAAY,CAAC,KAAKC,cAAN,CAAZ,CAEA,KAAKC,OAAL,CAAatB,EAAb,EACA,KAAKM,SAAL,CAAeN,EAAf,EACD,CACF,CACD,GAAIA,EAAE,CAACQ,OAAH,EAAcR,EAAE,CAACuB,WAAH,CAAiB,CAAnC,CAAsC,CACpCC,UAAU,CAAC,UAAM,CAGf,GAAI,MAAI,CAACb,gBAAT,CAA2B,CACzB,MAAI,CAACC,WAAL,CAAiBZ,EAAjB,EACD,CACF,CANS,CAAV,CAOD,CAED,GAAI,KAAKa,gBAAT,CAA2B,CACzB,OACD,CAGD,GAAIb,EAAE,CAACQ,OAAP,CAAgB,CAGd,GAAIR,EAAE,CAACuB,WAAH,CAAiB,CAArB,CAAwB,CACtBC,UAAU,CAAC,UAAM,CACf,GAAI,MAAI,CAACb,gBAAT,CAA2B,CACzB,MAAI,CAACC,WAAL,CAAiBZ,EAAjB,EACD,CACF,CAJS,CAAV,CAKD,CAGDoB,YAAY,CAAC,KAAKK,MAAN,CAAZ,CAEA,KAAKA,MAAL,CAAcD,UAAU,CAAC,UAAM,CAC7B,MAAI,CAACX,gBAAL,CAAwB,IAAxB,CACA,MAAI,CAACD,WAAL,CAAiBZ,EAAjB,EACD,CAHuB,CAGrB,KAAK0B,UAHgB,CAAxB,CAID,CAlBD,IAkBO,IAAI,CAAC,KAAKb,gBAAN,EAA0B,CAAC,KAAKF,gBAApC,CAAsD,CAE3D,GAAMG,CAAAA,QAAO,CAAG,KAAKC,MAAL,CAAYC,GAAZ,CAAgB,KAAKC,IAArB,CAAhB,CACA,GAAIH,QAAO,CAACI,OAAR,CAAgBC,MAAhB,CAAuBL,QAAvB,CAAgCd,EAAhC,CAAJ,CAAyC,CACvCoB,YAAY,CAAC,KAAKC,cAAN,CAAZ,CAEA,KAAKC,OAAL,CAAatB,EAAb,EACA,KAAKM,SAAL,CAAeN,EAAf,EACD,CACF,CACF,C,yDAEiB,CAChB,8GAEE2B,KAAK,CAAE,KAAKV,IAFd,CAGEW,IAAI,CAAE/B,KAAK,CAAC,KAAKgC,MAAL,CAAYC,YAAb,CAAL,CAAkC,CAAlC,CAAsC,KAAKD,MAAL,CAAYC,YAH1D,CAIEC,QAAQ,CAAE,KAAKL,UAJjB,CAKEM,IAAI,CACFnC,KAAK,CAAC,KAAKgC,MAAL,CAAYI,aAAb,CAAL,EAAoC,KAAKJ,MAAL,CAAYI,aAAZ,EAA6B,IAAjE,CACI,GADJ,CAEI,KAAKJ,MAAL,CAAYI,aARpB,GAUD,C,qEAcE,gCAXDC,uBAWC,CAXDA,uBAWC,gCAXyB,IAWzB,2CAVDC,SAUC,CAVDA,SAUC,yBAVWC,MAAM,CAACC,GAUlB,oCATDC,SASC,CATDA,SASC,yBATWF,MAAM,CAACC,GASlB,uCARDP,YAQC,CARDA,YAQC,4BARc,CAQd,2CAPDS,aAOC,CAPDA,aAOC,6BAPe,GAOf,yCANDb,UAMC,CANDA,UAMC,0BANYU,MAAM,CAACC,GAMnB,yCALDJ,aAKC,CALDA,aAKC,6BALeG,MAAM,CAACC,GAKtB,sCAJDG,OAIC,CAJDA,OAIC,uBAJS,CAIT,oCAHDC,WAGC,CAHDA,WAGC,2BAHa,CAGb,wCAFDlB,WAEC,CAFDA,WAEC,2BAFa,CAEb,kBADEmB,KACF,sLACD,8GACER,uBAAuB,CAAvBA,uBADF,CAEEJ,YAAY,CAAZA,YAFF,CAGEK,SAAS,CAATA,SAHF,CAIEG,SAAS,CAATA,SAJF,CAKEC,aAAa,CAAbA,aALF,CAMEb,UAAU,CAAVA,UANF,CAOEc,OAAO,CAAPA,OAPF,CAQEC,WAAW,CAAXA,WARF,CASElB,WAAW,CAAXA,WATF,EAUKmB,KAVL,GAYD,C,uDAEwB,WACvBtB,YAAY,CAAC,KAAKK,MAAN,CAAZ,CADuB,+BAAPiB,KAAO,+CAAPA,KAAO,0BAEvB,gHAAwBA,KAAxB,GACD,C,sDAEc5B,O,CAAS,CACtB,GAAI,KAAKX,mBAAT,CAA8B,CAC5B,KAAKJ,eAAL,CAAqB,KAAKI,mBAA1B,EACA,KAAKA,mBAAL,CAA2B,IAA3B,CACD,CACF,C,gCAvJU,CACT,MAAO,KAAP,CACD,C,8CAEwB,CACvB,MAAOR,CAAAA,MAAM,CAACgD,GAAd,CACD,C,sCAEgB,CACf,MAAO9C,CAAAA,KAAK,CAAC,KAAKgC,MAAL,CAAYH,UAAb,CAAL,CAAgC,GAAhC,CAAsC,KAAKG,MAAL,CAAYH,UAAzD,CACD,C,+BAX6B9B,sB,EA0JhC,cAAeE,CAAAA,iBAAf","sourcesContent":["import Hammer from 'hammerjs';\n\nimport DiscreteGestureHandler from './DiscreteGestureHandler';\nimport { isnan } from './utils';\n\nclass TapGestureHandler extends DiscreteGestureHandler {\n  get name() {\n    return 'tap';\n  }\n\n  get NativeGestureClass() {\n    return Hammer.Tap;\n  }\n\n  get maxDelayMs() {\n    return isnan(this.config.maxDelayMs) ? 300 : this.config.maxDelayMs;\n  }\n\n  simulateCancelEvent(inputData) {\n    if (this.isGestureRunning) {\n      this.cancelEvent(inputData);\n    }\n  }\n\n  onGestureActivated(ev) {\n    if (this.isGestureRunning) {\n      this.onSuccessfulTap(ev);\n    }\n  }\n\n  onSuccessfulTap = ev => {\n    if (this._getPendingGestures().length) {\n      this._shouldFireEndEvent = ev;\n      return;\n    }\n    if (ev.eventType === Hammer.INPUT_END) {\n      this.sendEvent({ ...ev, eventType: Hammer.INPUT_MOVE });\n    }\n    // When handler gets activated it will turn into State.END immediately.\n    this.sendEvent({ ...ev, isFinal: true });\n    this.onGestureEnded(ev);\n  };\n\n  onRawEvent(ev) {\n    super.onRawEvent(ev);\n\n    // Attempt to create a touch-down event by checking if a valid tap hasn't started yet, then validating the input.\n    if (\n      !this.hasGestureFailed &&\n      !this.isGestureRunning &&\n      // Prevent multi-pointer events from misfiring.\n      !ev.isFinal\n    ) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n    if (ev.isFinal && ev.maxPointers > 1) {\n      setTimeout(() => {\n        // Handle case where one finger presses slightly\n        // after the first finger on a multi-tap event\n        if (this.isGestureRunning) {\n          this.cancelEvent(ev);\n        }\n      });\n    }\n\n    if (this.hasGestureFailed) {\n      return;\n    }\n    // Hammer doesn't send a `cancel` event for taps.\n    // Manually fail the event.\n    if (ev.isFinal) {\n      // Handle case where one finger presses slightly\n      // after the first finger on a multi-tap event\n      if (ev.maxPointers > 1) {\n        setTimeout(() => {\n          if (this.isGestureRunning) {\n            this.cancelEvent(ev);\n          }\n        });\n      }\n\n      // Clear last timer\n      clearTimeout(this._timer);\n      // Create time out for multi-taps.\n      this._timer = setTimeout(() => {\n        this.hasGestureFailed = true;\n        this.cancelEvent(ev);\n      }, this.maxDelayMs);\n    } else if (!this.hasGestureFailed && !this.isGestureRunning) {\n      // Tap Gesture start event\n      const gesture = this.hammer.get(this.name);\n      if (gesture.options.enable(gesture, ev)) {\n        clearTimeout(this._multiTapTimer);\n\n        this.onStart(ev);\n        this.sendEvent(ev);\n      }\n    }\n  }\n\n  getHammerConfig() {\n    return {\n      ...super.getHammerConfig(),\n      event: this.name,\n      taps: isnan(this.config.numberOfTaps) ? 1 : this.config.numberOfTaps,\n      interval: this.maxDelayMs,\n      time:\n        isnan(this.config.maxDurationMs) || this.config.maxDurationMs == null\n          ? 250\n          : this.config.maxDurationMs,\n    };\n  }\n\n  updateGestureConfig({\n    shouldCancelWhenOutside = true,\n    maxDeltaX = Number.NaN,\n    maxDeltaY = Number.NaN,\n    numberOfTaps = 1,\n    minDurationMs = 525,\n    maxDelayMs = Number.NaN,\n    maxDurationMs = Number.NaN,\n    maxDist = 2,\n    minPointers = 1,\n    maxPointers = 1,\n    ...props\n  }) {\n    return super.updateGestureConfig({\n      shouldCancelWhenOutside,\n      numberOfTaps,\n      maxDeltaX,\n      maxDeltaY,\n      minDurationMs,\n      maxDelayMs,\n      maxDist,\n      minPointers,\n      maxPointers,\n      ...props,\n    });\n  }\n\n  onGestureEnded(...props) {\n    clearTimeout(this._timer);\n    super.onGestureEnded(...props);\n  }\n\n  onWaitingEnded(gesture) {\n    if (this._shouldFireEndEvent) {\n      this.onSuccessfulTap(this._shouldFireEndEvent);\n      this._shouldFireEndEvent = null;\n    }\n  }\n}\nexport default TapGestureHandler;\n"]},"metadata":{},"sourceType":"module"}